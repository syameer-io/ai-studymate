/// Study Plan Model
///
/// Represents a study plan generated by the Laravel API.
/// Contains schedule data, recommendations, and computed properties.

import 'package:intl/intl.dart';

/// Study Subject - Input for study plan generation
class StudySubject {
  final String name;
  final String difficulty; // easy, medium, hard
  final DateTime examDate;

  const StudySubject({
    required this.name,
    required this.difficulty,
    required this.examDate,
  });

  /// Create from JSON
  factory StudySubject.fromJson(Map<String, dynamic> json) {
    return StudySubject(
      name: json['name'] ?? '',
      difficulty: json['difficulty'] ?? 'medium',
      examDate: _parseDate(json['examDate'] ?? json['exam_date']),
    );
  }

  /// Convert to JSON for API request
  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'difficulty': difficulty,
      'examDate': DateFormat('yyyy-MM-dd').format(examDate),
    };
  }

  static DateTime _parseDate(dynamic value) {
    if (value == null) return DateTime.now();
    if (value is DateTime) return value;
    if (value is String) {
      return DateTime.tryParse(value) ?? DateTime.now();
    }
    return DateTime.now();
  }

  /// Create a copy with updated fields
  StudySubject copyWith({
    String? name,
    String? difficulty,
    DateTime? examDate,
  }) {
    return StudySubject(
      name: name ?? this.name,
      difficulty: difficulty ?? this.difficulty,
      examDate: examDate ?? this.examDate,
    );
  }
}

/// Study Task - Single task in a daily schedule
class StudyTask {
  final String subject;
  final String topic;
  final int duration; // hours
  final String startTime; // HH:mm format

  const StudyTask({
    required this.subject,
    required this.topic,
    required this.duration,
    required this.startTime,
  });

  /// Create from JSON
  factory StudyTask.fromJson(Map<String, dynamic> json) {
    return StudyTask(
      subject: json['subject'] ?? '',
      topic: json['topic'] ?? '',
      duration: _parseInt(json['duration']),
      startTime: json['startTime'] ?? json['start_time'] ?? '08:00',
    );
  }

  /// Convert to JSON
  Map<String, dynamic> toJson() {
    return {
      'subject': subject,
      'topic': topic,
      'duration': duration,
      'startTime': startTime,
    };
  }

  static int _parseInt(dynamic value) {
    if (value == null) return 1;
    if (value is int) return value;
    if (value is String) return int.tryParse(value) ?? 1;
    return 1;
  }

  /// Get formatted duration string
  String get formattedDuration {
    if (duration == 1) return '1 hour';
    return '$duration hours';
  }

  /// Get formatted time string (e.g., "9:00 AM")
  String get formattedTime {
    try {
      final parts = startTime.split(':');
      if (parts.length >= 2) {
        final hour = int.parse(parts[0]);
        final minute = int.parse(parts[1]);
        final now = DateTime.now();
        final dateTime = DateTime(now.year, now.month, now.day, hour, minute);
        return DateFormat('h:mm a').format(dateTime);
      }
    } catch (_) {}
    return startTime;
  }
}

/// Daily Schedule - A day's worth of study tasks
class DailySchedule {
  final DateTime date;
  final List<StudyTask> tasks;

  const DailySchedule({
    required this.date,
    required this.tasks,
  });

  /// Create from JSON
  factory DailySchedule.fromJson(Map<String, dynamic> json) {
    final tasksList = json['tasks'] as List<dynamic>? ?? [];
    return DailySchedule(
      date: _parseDate(json['date']),
      tasks: tasksList.map((t) => StudyTask.fromJson(t as Map<String, dynamic>)).toList(),
    );
  }

  /// Convert to JSON
  Map<String, dynamic> toJson() {
    return {
      'date': DateFormat('yyyy-MM-dd').format(date),
      'tasks': tasks.map((t) => t.toJson()).toList(),
    };
  }

  static DateTime _parseDate(dynamic value) {
    if (value == null) return DateTime.now();
    if (value is DateTime) return value;
    if (value is String) {
      return DateTime.tryParse(value) ?? DateTime.now();
    }
    return DateTime.now();
  }

  /// Get formatted date string (e.g., "Jan 15, 2026")
  String get formattedDate {
    return DateFormat('MMM d, yyyy').format(date);
  }

  /// Get formatted date with day name (e.g., "Monday, Jan 15")
  String get formattedDateWithDay {
    return DateFormat('EEEE, MMM d').format(date);
  }

  /// Check if this schedule is for today
  bool get isToday {
    final now = DateTime.now();
    return date.year == now.year && date.month == now.month && date.day == now.day;
  }

  /// Check if this schedule is in the past
  bool get isPast {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final scheduleDay = DateTime(date.year, date.month, date.day);
    return scheduleDay.isBefore(today);
  }

  /// Get total study hours for this day
  int get totalHours {
    return tasks.fold(0, (sum, task) => sum + task.duration);
  }

  /// Get unique subjects for this day
  Set<String> get subjects {
    return tasks.map((t) => t.subject).toSet();
  }
}

/// Study Plan Model - Main model for study plans
class StudyPlanModel {
  /// Laravel database ID
  final int id;

  /// Owner's Firebase user ID
  final String userId;

  /// Plan title
  final String title;

  /// Daily schedule list
  final List<DailySchedule> schedule;

  /// AI-generated recommendations
  final List<String> recommendations;

  /// Whether this is the active plan
  final bool isActive;

  /// Creation timestamp
  final DateTime createdAt;

  /// Last modification timestamp
  final DateTime updatedAt;

  const StudyPlanModel({
    required this.id,
    required this.userId,
    required this.title,
    required this.schedule,
    this.recommendations = const [],
    this.isActive = false,
    required this.createdAt,
    required this.updatedAt,
  });

  /// Create from API JSON response
  factory StudyPlanModel.fromJson(Map<String, dynamic> json) {
    final scheduleList = json['schedule'] as List<dynamic>? ?? [];
    final recommendationsList = json['recommendations'] as List<dynamic>? ?? [];

    return StudyPlanModel(
      id: json['id'] ?? 0,
      userId: json['user_id']?.toString() ?? '',
      title: json['title'] ?? 'Study Plan',
      schedule: scheduleList.map((s) => DailySchedule.fromJson(s as Map<String, dynamic>)).toList(),
      recommendations: recommendationsList.map((r) => r.toString()).toList(),
      isActive: json['is_active'] == true || json['is_active'] == 1,
      createdAt: _parseDateTime(json['created_at']),
      updatedAt: _parseDateTime(json['updated_at']),
    );
  }

  static DateTime _parseDateTime(dynamic value) {
    if (value == null) return DateTime.now();
    if (value is DateTime) return value;
    if (value is String) {
      return DateTime.tryParse(value) ?? DateTime.now();
    }
    return DateTime.now();
  }

  /// Convert to JSON
  Map<String, dynamic> toJson() {
    return {
      if (id > 0) 'id': id,
      'userId': userId,
      'title': title,
      'schedule': schedule.map((s) => s.toJson()).toList(),
      'recommendations': recommendations,
      'isActive': isActive,
    };
  }

  /// Create a copy with updated fields
  StudyPlanModel copyWith({
    int? id,
    String? userId,
    String? title,
    List<DailySchedule>? schedule,
    List<String>? recommendations,
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return StudyPlanModel(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      title: title ?? this.title,
      schedule: schedule ?? this.schedule,
      recommendations: recommendations ?? this.recommendations,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? DateTime.now(),
    );
  }

  // ========== COMPUTED PROPERTIES ==========

  /// Get total days in the plan
  int get totalDays => schedule.length;

  /// Get start date of the plan
  DateTime? get startDate {
    if (schedule.isEmpty) return null;
    return schedule.first.date;
  }

  /// Get end date of the plan
  DateTime? get endDate {
    if (schedule.isEmpty) return null;
    return schedule.last.date;
  }

  /// Get remaining days (from today to end)
  int get remainingDays {
    if (endDate == null) return 0;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final end = DateTime(endDate!.year, endDate!.month, endDate!.day);
    final remaining = end.difference(today).inDays;
    return remaining > 0 ? remaining : 0;
  }

  /// Get days completed (from start to today)
  int get completedDays {
    if (startDate == null) return 0;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final start = DateTime(startDate!.year, startDate!.month, startDate!.day);
    final completed = today.difference(start).inDays;
    return completed > 0 ? (completed > totalDays ? totalDays : completed) : 0;
  }

  /// Get progress percentage (0.0 to 1.0)
  double get progressPercentage {
    if (totalDays == 0) return 0.0;
    return completedDays / totalDays;
  }

  /// Get today's schedule
  DailySchedule? get todaysSchedule {
    final now = DateTime.now();
    try {
      return schedule.firstWhere((s) =>
          s.date.year == now.year &&
          s.date.month == now.month &&
          s.date.day == now.day);
    } catch (_) {
      return null;
    }
  }

  /// Get upcoming schedules (from tomorrow)
  List<DailySchedule> get upcomingSchedules {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    return schedule.where((s) {
      final scheduleDay = DateTime(s.date.year, s.date.month, s.date.day);
      return scheduleDay.isAfter(today);
    }).toList();
  }

  /// Get past schedules
  List<DailySchedule> get pastSchedules {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    return schedule.where((s) {
      final scheduleDay = DateTime(s.date.year, s.date.month, s.date.day);
      return scheduleDay.isBefore(today);
    }).toList();
  }

  /// Get all unique subjects in the plan
  Set<String> get subjects {
    final allSubjects = <String>{};
    for (final day in schedule) {
      allSubjects.addAll(day.subjects);
    }
    return allSubjects;
  }

  /// Get formatted date range (e.g., "Jan 15 - Feb 10, 2026")
  String get dateRangeFormatted {
    if (startDate == null || endDate == null) return 'No schedule';

    final startFormatter = DateFormat('MMM d');
    final endFormatter = DateFormat('MMM d, yyyy');

    if (startDate!.year == endDate!.year && startDate!.month == endDate!.month) {
      // Same month and year
      return '${startFormatter.format(startDate!)} - ${endFormatter.format(endDate!)}';
    }

    return '${startFormatter.format(startDate!)} - ${endFormatter.format(endDate!)}';
  }

  /// Get total study hours across all days
  int get totalStudyHours {
    return schedule.fold(0, (sum, day) => sum + day.totalHours);
  }

  /// Check if plan has started
  bool get hasStarted {
    if (startDate == null) return false;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final start = DateTime(startDate!.year, startDate!.month, startDate!.day);
    return !start.isAfter(today);
  }

  /// Check if plan has ended
  bool get hasEnded {
    if (endDate == null) return false;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final end = DateTime(endDate!.year, endDate!.month, endDate!.day);
    return end.isBefore(today);
  }

  /// Check if plan is currently in progress
  bool get isInProgress => hasStarted && !hasEnded;

  @override
  String toString() {
    return 'StudyPlanModel(id: $id, title: $title, days: $totalDays, subjects: ${subjects.join(", ")})';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is StudyPlanModel && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}
